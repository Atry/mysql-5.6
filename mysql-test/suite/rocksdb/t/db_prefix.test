--source include/have_rocksdb.inc
--source include/master-slave.inc

--echo ################################################
--echo # Test db and index number assignment
--echo ################################################
create database db1;
use db1;
create table t1(a int primary key, b int, key(b));

create database db2;
use db2;
create table t1(a int primary key, b int, key(b));

select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;

drop database db1;
drop database db2;

--echo ################################################
--echo # Recreate the database with the same name
--echo ################################################
create database db1;
use db1;
create table t1(a int primary key, b int, key(b));

select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;

drop database db1;

--echo ################################################
--echo # Verify the key composition of the row 
--echo ################################################
create database db1;
use db1;
create table t1(a int primary key);
insert into t1 values(999);

# Use the fact that the rocksdb_locks shows the keys as they are encoded to
# validate that the keys were encoded as expected
BEGIN;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

drop database db1;

--echo ####################################################
--echo # Verify database entry is preserved across restart 
--echo ####################################################
create database db1;
use db1;
create table t1(a int primary key);
insert into t1 values(999);

BEGIN;
SELECT * from t1;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

select * from information_schema.rocksdb_ddl where table_schema='db1';

let $rpl_server_number= 1;
source include/rpl_restart_server.inc;
let $rpl_server_number= 2;
source include/rpl_restart_server.inc;
connection slave;
--source include/start_slave.inc
connection master;

select * from information_schema.rocksdb_ddl where table_schema='db1';

# Verify entries of table t1 are not leaked after being dropped.
BEGIN;
SELECT * from t1;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

drop database db1;

--echo ################################################
--echo # Verify drop database drops the table 
--echo ################################################
create database db1;
use db1;
create table t1(a int primary key);
insert into t1 values(999);

BEGIN;
SELECT * from t1;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

select * from information_schema.rocksdb_ddl where table_schema='db1';
drop database db1;
select * from information_schema.rocksdb_ddl where table_schema='db1';

--error 1049
SELECT * from db1.t1;

let $rpl_server_number= 1;
source include/rpl_restart_server.inc;
let $rpl_server_number= 2;
source include/rpl_restart_server.inc;
connection slave;
--source include/start_slave.inc
connection master;

--error 1049
SELECT * from db1.t1;
select * from information_schema.rocksdb_ddl where table_schema='db1';

create database db1;
use db1;
create table t1(a int primary key);
insert into t1 values(1000);
select * from information_schema.rocksdb_ddl where table_schema='db1';

# Verify entries of table t1 are not leaked after being dropped.
BEGIN;
SELECT * from t1;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

drop database db1;

--echo ################################################
--echo # Test db prefix content on secondary
--echo ################################################
connection master;
create database db1;
use db1;
create table t1(a int primary key);

select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;

# make sure the slave is caught up
--source include/sync_slave_sql_with_master.inc

connection slave;
select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;

connection default;
drop database db1;

--echo ################################################
--echo # Test db rename scenario
--echo ################################################
connection default;
create database db1;
create database db2;

use db1;
create table t1(a int primary key);
insert into t1 values(999);

# Use the fact that the rocksdb_locks shows the keys as they are encoded to
# validate that the keys were encoded as expected
BEGIN;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;

# rename table to another database
rename table db1.t1 to db2.t1;

use db2;
create table t2(a int primary key);
insert into t2 values(999);

# check rocksddb_ddl contents
select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;
select * from information_schema.rocksdb_ddl where table_schema='db2' order by table_name;

# Test db_prefix of key for t1 and t2
BEGIN;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT hex(a) FROM t2 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

# Insert another row and verify the db_id prefix of the table
insert into t1 values(1000);
BEGIN;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT hex(a) FROM t2 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;


drop database db1;
drop database db2;

--echo ################################################
--echo # Test db rename scenario on secondaries
--echo ################################################
connection master;
create database db1;
create database db2;

use db1;
create table t1(a int primary key);
insert into t1 values(999);

# make sure the slave is caught up
--source include/sync_slave_sql_with_master.inc
connection slave;

# Use the fact that the rocksdb_locks shows the keys as they are encoded to
# validate that the keys were encoded as expected
use db1;
BEGIN;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;

connection master;

# rename table to another database
rename table db1.t1 to db2.t1;

use db2;
create table t2(a int primary key);
insert into t2 values(999);

--source include/sync_slave_sql_with_master.inc
connection slave;

# check rocksddb_ddl contents
select * from information_schema.rocksdb_ddl where table_name='t1' order by table_schema;
select * from information_schema.rocksdb_ddl where table_schema='db2' order by table_name;

# Test db_prefix of key for t1 and t2
use db2;
BEGIN;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT hex(a) FROM t2 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

# Insert another row and verify the db_id prefix of the table
insert into t1 values(1000);
BEGIN;
SELECT hex(a) FROM t1 FOR UPDATE;
SELECT hex(a) FROM t2 FOR UPDATE;
SELECT SUBSTRING(a.key,1,8), SUBSTRING(a.key,9,8) FROM information_schema.rocksdb_locks AS a ORDER BY a.key;
ROLLBACK;

connection default;
drop database db1;
drop database db2;

--echo ################################################
--echo # Cleanup
--echo ################################################
--source include/rpl_end.inc
